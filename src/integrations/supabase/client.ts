// // // This file is automatically generated. Do not edit it directly.
// import { createClient } from "@supabase/supabase-js";
// import type { Database } from "./types";

// const SUPABASE_URL = "https://ltjlswzrdgtoddyqmydo.supabase.co";
// const SUPABASE_PUBLISHABLE_KEY =
//   "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx0amxzd3pyZGd0b2RkeXFteWRvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1NDA5OTIsImV4cCI6MjA2MDExNjk5Mn0.YXg-x4oflJUdoRdQQQGI2NisUqUVHAXkhgyrr-4CoE0";

// // Import the supabase client like this:
// // import { supabase } from "@/integrations/supabase/client";

// export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
//   auth: {
//     autoRefreshToken: true,
//     persistSession: true,
//     detectSessionInUrl: true,
//   },
// });

// integrations/supabase/client.ts
// import { createClient } from "@supabase/supabase-js";
// import type { Database } from "./types";

// const SUPABASE_URL = "https://ltjlswzrdgtoddyqmydo.supabase.co";
// const SUPABASE_PUBLISHABLE_KEY =
//   "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx0amxzd3pyZGd0b2RkeXFteWRvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1NDA5OTIsImV4cCI6MjA2MDExNjk5Mn0.YXg-x4oflJUdoRdQQQGI2NisUqUVHAXkhgyrr-4CoE0";

// const COOKIE_NAME = "sb-auth-token";

// function getCookie(name: string) {
//   const match = document.cookie.match(new RegExp("(^| )" + name + "=([^;]+)"));
//   return match ? decodeURIComponent(match[2]) : null;
// }

// function setCookie(name: string, value: string, days = 7) {
//   const expires = new Date(Date.now() + days * 864e5).toUTCString();
//   document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/; SameSite=Lax`;
// }

// function deleteCookie(name: string) {
//   document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
// }

// export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
//   auth: {
//     autoRefreshToken: true,
//     persistSession: true,
//     detectSessionInUrl: true,
//   },
// });

// // üîÑ Keep cookie updated when session changes
// supabase.auth.onAuthStateChange((_, session) => {
//   if (session?.access_token) {
//     setCookie(COOKIE_NAME, JSON.stringify(session));
//   } else {
//     deleteCookie(COOKIE_NAME);
//   }
// });

// // üîÅ Restore session from cookie (used in App.tsx)
// export async function restoreSessionFromCookie() {
//   const cookieValue = getCookie(COOKIE_NAME);
//   if (cookieValue) {
//     try {
//       const session = JSON.parse(cookieValue);
//       if (session?.access_token) {
//         await supabase.auth.setSession(session);
//         console.log("‚úÖ Restored session from cookie");
//         return session;
//       }
//     } catch (e) {
//       console.error("Failed to parse cookie session:", e);
//     }
//   }
//   return null;
// }

// integrations/supabase/client.ts
import { createClient } from "@supabase/supabase-js";
import type { Database } from "./types";

/**
 * üß† Purpose:
 * - Keeps session alive after tab inactivity or browser sleep
 * - Automatically restores session from cookie
 * - Ensures Realtime reconnection on tab focus
 * - Fixes query timeout issues after long idle periods
 */

const SUPABASE_URL = "https://ltjlswzrdgtoddyqmydo.supabase.co";
const SUPABASE_PUBLISHABLE_KEY =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imx0amxzd3pyZGd0b2RkeXFteWRvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1NDA5OTIsImV4cCI6MjA2MDExNjk5Mn0.YXg-x4oflJUdoRdQQQGI2NisUqUVHAXkhgyrr-4CoE0";

const COOKIE_NAME = "sb-auth-token";
const SESSION_STORAGE_KEY = "sb-session-backup"; // CRITICAL: sessionStorage works better in iframes

/* ----------------------- Multi-Layer Storage Helpers ----------------------- */
function getCookie(name: string) {
  const match = document.cookie.match(new RegExp("(^| )" + name + "=([^;]+)"));
  return match ? decodeURIComponent(match[2]) : null;
}

function setCookie(name: string, value: string, days = 7) {
  const expires = new Date(Date.now() + days * 864e5).toUTCString();
  document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/; SameSite=Lax`;
}

function deleteCookie(name: string) {
  document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;
}

function getSessionStorage(key: string) {
  try {
    const value = sessionStorage.getItem(key);
    return value;
  } catch (e) {
    console.warn('sessionStorage not available:', e);
    return null;
  }
}

function setSessionStorage(key: string, value: string) {
  try {
    sessionStorage.setItem(key, value);
    return true;
  } catch (e) {
    console.warn('Failed to set sessionStorage:', e);
    return false;
  }
}

function deleteSessionStorage(key: string) {
  try {
    sessionStorage.removeItem(key);
  } catch (e) {
    console.warn('Failed to delete sessionStorage:', e);
  }
}

/* ----------------------- Supabase Client ----------------------- */
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
  },
  realtime: {
    params: {
      eventsPerSecond: 5,
    },
  },
});

/* ----------------------- Auth State Sync ----------------------- */
supabase.auth.onAuthStateChange(async (event, session) => {
  console.log(`üîê Auth state changed: ${event}`, session ? 'has session' : 'no session');
  
  // CRITICAL FIX: Only delete storage on explicit SIGN_OUT
  if (event === "SIGNED_OUT") {
    console.log("üîê User signed out - clearing all session storage");
    deleteCookie(COOKIE_NAME);
    deleteSessionStorage(SESSION_STORAGE_KEY);
    stopPeriodicBackup();
    stopKeepalive();
  } else if (session?.access_token) {
    // Validate session hasn't expired before saving
    const expiresAt = session.expires_at ? session.expires_at * 1000 : 0;
    const isExpired = expiresAt > 0 && Date.now() >= expiresAt;
    
    if (!isExpired) {
      const sessionStr = JSON.stringify(session);
      
      // MULTI-LAYER BACKUP: Save to both cookie AND sessionStorage
      setCookie(COOKIE_NAME, sessionStr);
      setSessionStorage(SESSION_STORAGE_KEY, sessionStr);
      console.log("üíæ Session saved to multi-layer backup (cookie + sessionStorage)");
      
      // Start both periodic backup and keepalive
      if (event === "SIGNED_IN" || event === "TOKEN_REFRESHED") {
        startPeriodicBackup();
        startKeepalive();
      }
    } else {
      console.warn("‚ö†Ô∏è Session expired, not saving");
    }
  }

  if (event === "TOKEN_REFRESHED") {
    console.log("üîÅ Token refreshed successfully");
  }
});

/* ----------------------- Restore Session ----------------------- */
export async function restoreSessionFromBackup() {
  console.log("üîÑ Attempting multi-layer session restoration...");
  
  // LAYER 1: Try sessionStorage first (most reliable in iframes)
  console.log("üì¶ Trying sessionStorage...");
  const sessionStorageValue = getSessionStorage(SESSION_STORAGE_KEY);
  
  if (sessionStorageValue) {
    try {
      const session = JSON.parse(sessionStorageValue);
      
      if (session?.access_token) {
        // Validate session hasn't expired
        const expiresAt = session?.expires_at ? session.expires_at * 1000 : 0;
        const isExpired = expiresAt > 0 && Date.now() >= expiresAt;
        
        if (!isExpired) {
          console.log("‚úÖ Valid session found in sessionStorage, restoring...");
          
          const { data, error } = await supabase.auth.setSession({
            access_token: session.access_token,
            refresh_token: session.refresh_token
          });
          
          if (!error && data.session) {
            console.log("‚úÖ Successfully restored session from sessionStorage");
            
            // Re-save to all layers
            const sessionStr = JSON.stringify(data.session);
            setCookie(COOKIE_NAME, sessionStr);
            setSessionStorage(SESSION_STORAGE_KEY, sessionStr);
            
            startPeriodicBackup();
            startKeepalive();
            
            return data.session;
          }
        } else {
          console.warn("‚ö†Ô∏è sessionStorage session expired");
          deleteSessionStorage(SESSION_STORAGE_KEY);
        }
      }
    } catch (e) {
      console.warn("‚ùå Failed to restore from sessionStorage:", e);
      deleteSessionStorage(SESSION_STORAGE_KEY);
    }
  }
  
  // LAYER 2: Try cookie as fallback
  console.log("üç™ Trying cookie backup...");
  const cookieValue = getCookie(COOKIE_NAME);
  
  if (cookieValue) {
    try {
      const session = JSON.parse(cookieValue);
      
      if (session?.access_token) {
        const expiresAt = session?.expires_at ? session.expires_at * 1000 : 0;
        const isExpired = expiresAt > 0 && Date.now() >= expiresAt;
        
        if (!isExpired) {
          console.log("‚úÖ Valid session found in cookie, restoring...");
          
          const { data, error } = await supabase.auth.setSession({
            access_token: session.access_token,
            refresh_token: session.refresh_token
          });
          
          if (!error && data.session) {
            console.log("‚úÖ Successfully restored session from cookie");
            
            // Re-save to all layers
            const sessionStr = JSON.stringify(data.session);
            setCookie(COOKIE_NAME, sessionStr);
            setSessionStorage(SESSION_STORAGE_KEY, sessionStr);
            
            startPeriodicBackup();
            startKeepalive();
            
            return data.session;
          }
        } else {
          console.warn("‚ö†Ô∏è Cookie session expired");
          deleteCookie(COOKIE_NAME);
        }
      }
    } catch (e) {
      console.warn("‚ùå Failed to restore from cookie:", e);
      deleteCookie(COOKIE_NAME);
    }
  }
  
  console.warn("‚ùå No valid session found in any backup layer");
  return null;
}

/* ----------------------- Force Save Session ----------------------- */
export function forceSessionBackup(session: any) {
  if (session?.access_token) {
    // Validate session isn't expired
    const expiresAt = session.expires_at ? session.expires_at * 1000 : 0;
    const isExpired = expiresAt > 0 && Date.now() >= expiresAt;
    
    if (!isExpired) {
      const sessionStr = JSON.stringify(session);
      setCookie(COOKIE_NAME, sessionStr);
      setSessionStorage(SESSION_STORAGE_KEY, sessionStr);
      console.log("üíæ Forced multi-layer session backup");
      return true;
    } else {
      console.warn("‚ö†Ô∏è Session expired, not backing up");
      return false;
    }
  }
  return false;
}

/* ----------------------- Periodic Session Backup ----------------------- */
let periodicBackupInterval: NodeJS.Timeout | null = null;

function startPeriodicBackup() {
  if (periodicBackupInterval) {
    console.log("‚è∞ Periodic backup already running");
    return;
  }
  
  console.log("‚è∞ Starting periodic session backup (every 15s)");
  
  periodicBackupInterval = setInterval(async () => {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (session?.access_token) {
        const saved = forceSessionBackup(session);
        if (saved) {
          console.log("‚è∞ Periodic session backup successful");
        }
      } else {
        console.log("‚è∞ No active session to backup");
        stopPeriodicBackup();
      }
    } catch (error) {
      console.error("‚è∞ Periodic backup error:", error);
    }
  }, 15000); // CRITICAL: Every 15 seconds for more frequent backups
}

function stopPeriodicBackup() {
  if (periodicBackupInterval) {
    clearInterval(periodicBackupInterval);
    periodicBackupInterval = null;
    console.log("‚è∞ Stopped periodic session backup");
  }
}

/* ----------------------- Session Keepalive ----------------------- */
let keepaliveInterval: NodeJS.Timeout | null = null;

function startKeepalive() {
  if (keepaliveInterval) {
    console.log("üíì Keepalive already running");
    return;
  }
  
  console.log("üíì Starting session keepalive (every 4 minutes)");
  
  keepaliveInterval = setInterval(async () => {
    try {
      // CRITICAL: Actively refresh the session to keep it alive
      const { data: { session }, error } = await supabase.auth.refreshSession();
      
      if (error) {
        console.warn("üíì Keepalive refresh failed:", error.message);
        // If refresh fails, stop keepalive
        stopKeepalive();
        return;
      }
      
      if (session) {
        console.log("üíì Session keepalive refresh successful");
        forceSessionBackup(session);
      } else {
        console.warn("üíì No session to keep alive");
        stopKeepalive();
      }
    } catch (error) {
      console.error("üíì Keepalive error:", error);
    }
  }, 4 * 60 * 1000); // Every 4 minutes (tokens expire after 1 hour)
}

function stopKeepalive() {
  if (keepaliveInterval) {
    clearInterval(keepaliveInterval);
    keepaliveInterval = null;
    console.log("üíì Stopped session keepalive");
  }
}

/* ----------------------- Realtime Reconnect Logic ----------------------- */
let reconnectTimeout: NodeJS.Timeout | null = null;

function reconnectRealtime() {
  if (reconnectTimeout) clearTimeout(reconnectTimeout);
  reconnectTimeout = setTimeout(async () => {
    try {
      console.log("üîå Reconnecting Supabase Realtime...");
      // CRITICAL FIX: Don't check for session here - it creates a race condition
      // The visibilityCoordinator will restore the session separately (takes ~800ms)
      // Just reconnect - Supabase will use the restored session automatically
      await supabase.realtime.connect();
      console.log("üü¢ Realtime reconnection initiated");
    } catch (error) {
      console.error("‚ùå Realtime reconnection failed:", error);
    }
  }, 1500); // Increased delay to allow session restoration to complete first
}

/* ----------------------- Handle Visibility Events ----------------------- */
// REMOVED: Duplicate visibility listener - now handled by visibilityCoordinator
// The visibilityCoordinator in UnifiedAuthContext handles:
// 1. Session restoration (via refreshAuth handler)
// 2. Pre-hide session backup
// 3. Realtime reconnection coordination
//
// This prevents race conditions from multiple visibility listeners

/* ----------------------- Health Ping & Auto-Start ----------------------- */
// Keeps connection warm in long-running sessions
setInterval(
  async () => {
    const { data } = await supabase.auth.getSession();
    if (data?.session?.access_token) {
      console.log("üíì Supabase session still active");
      // Ensure backup is running for active sessions
      if (!periodicBackupInterval) {
        startPeriodicBackup();
      }
    }
  },
  10 * 60 * 1000,
); // every 10 minutes

// Auto-start backup and keepalive if user is already logged in
(async () => {
  const { data: { session } } = await supabase.auth.getSession();
  if (session?.access_token) {
    console.log("üöÄ Auto-starting backup and keepalive for existing session");
    forceSessionBackup(session);
    startPeriodicBackup();
    startKeepalive();
  }
})();
